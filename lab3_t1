class Node:
    def __init__(self,data):
        self.data=data
        self.ref=None

class LinkedList:
    def __init__(self):
        self.head=None

    def insert_at_start(self,data):
        new_node=Node(data)
        if self.head is None:
            self.head=new_node
        else:
            new_node.ref=self.head
            self.head=new_node

    def insert_at_end(self,data):
        new_node=Node(data)

        current=self.head
        while current.ref is not None:
            current=current.ref
        current.ref=new_node

    def insert_after(self,key,data):
        new_node=Node(data)

        current=self.head
        while current is not None:
            if current.data==key:
                new_node.ref=current.ref
                current.ref=new_node
                break
            current=current.ref

    def insert_before(self,key,data):
        new_node=Node(data)
        

        current=self.head
        while current.ref is not None:
            if current.ref.data==key:
                new_node.ref=current.ref
                current.ref=new_node
                break
            current=current.ref

    def search(self,key):
        if self.head is None:
            print('List is empty')

        else:
            current=self.head
            while current is not None:
                if current.data==key:
                    return True
                current=current.ref

            return False



    def print_llist(self):
        if self.head is None:
            print('Linked List is empty')

        else:
            current=self.head
            while current is not None:
                print(current.data,end=' ')
                current=current.ref

    def remove_at_start(self):
        if self.head is None:
            return 'List is empty'
        current=self.head
        self.head=current.ref
        del current

    def remove_at_end(self):
        if self.head is None:
            return
        current=self.head
        current1=self.head
        while current.ref is not None:
            current1=current
            current=current.ref
        current1.ref=None

        del current

    def remove_before(self,key):
        if self.head is None:
            return
        current =self.head
        current1=self.head
        while current is not None:
            if current.ref.data==key:
                del current
                break

    def remove_before(self, key):
        if self.head is None:
            print('List is empty')
            return
        temp = self.head
        temp2 = self.head
        while temp.ref is not None:
            if temp.ref.data == key:
                temp2.ref = temp.ref
                del temp
                return
            temp2 = temp
            temp = temp.ref

    def remove_after(self, key):
        if self.head is None:
            print('List is empty')
            return
        temp = self.head
        temp2 = self.head
        while temp.ref is not None:
            if temp.data == key:
                temp.ref = temp2.ref
                del temp2
                return
            temp = temp.ref
            temp2 = temp.ref

    def update(self, key ,val):
        temp = self.head
        while temp is not None:
            if temp.data == key:
                temp.data = val
                return
            temp = temp.ref


    def dup_check(self):
        new_list=[]
        current=self.head
        print(current)

        while current is not None:
            if current.data not in new_list:
                print(current.data)
                new_list.append(current.data)

            

        # print(new_list) 
                
    def count(self):
        current=self.head
        count=0
        while current is not None:
            count+=1
            current=current.ref
        return count

                
    def removeKthnode(self,k):
        count=1
        current=self.head

        if self.count()<k:
            return False

        # if k==1:
        #     self.remove_at_start()
            
        
        # elif self.count()==k:
        #     self.remove_at_end()

        

        while current.ref.ref is not None:
            if count==k-1:
                new=current.ref.ref
                current.ref.ref=None
                current.ref=new
                break
                
            
            current=current.ref 
            count+=1   


    def combine(self,list1,list2):
        self.head=list1.head

        current=list1.head
        while current.ref is not None:
            current=current.ref
        current.ref=list2.head

    
    def shuffle_merge(self,list1,list2):
       self.head=list1.head
       
       current1=list1.head
       current2=list2.head

       while current1 is not None:
           next1=current1.ref
           next2=current2.ref

           current1=current2
           current2.ref=next1

           current1=next2
           current2=next2

       list1.head=None
       list2.head=None


        

    def remove_duplicates(self):
        if not self.head:
            return self.head
    
        new = []
        new.append(self.head.data)
        prev = self.head
        current = self.head.ref
    
        while current:
            if current.data in new:
                prev.ref = current.ref
            else:
                new.append(current.data)
                prev = current
            current = current.ref
        return self.head
           




        
def main():
    l1=LinkedList()
    l2=LinkedList()
    list3=LinkedList()
    l1.insert_at_start(10)
    l1.insert_at_start(10)
    l1.insert_at_start(20)
    l1.insert_at_start(30)
    l1.insert_at_end(5)
    l1.insert_after(10,15)
    l1.insert_before(10,12)
    l2.insert_at_start(14)
    l2.insert_at_end(7)
    l2.insert_at_end(9)
    # l1.remove_at_end()
    # l1.remove_at_start()
    # print(l1.search(12))
    l1.print_llist()
    print()
    # l1.remove_duplicates()
    # l1.print_llist()
    # l1.display_reverse_rec()
    l2.print_llist()
    # print()
    # list3.combine(l1,l2)
    list3.shuffle_merge(l1,l2)
    print()
    list3.print_llist()
    # l1.dup_check()
    # l1.removeKthnode(10)
    # print('updated list')
    # l1.print_llist()

    


main()